#!/usr/bin/python

# Copyright 2015 Jason Edelman <jason@networktocode.com>
# Network to Code, LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

ANSIBLE_METADATA = {'metadata_version': '1.0',
                    'status': ['preview'],
                    'supported_by': 'community'}

DOCUMENTATION = r'''
module: aci_rest
short_description: Direct access to the APIC API.
description:
- Offers direct access to the APIC API.
author: Jason Edelman (@jedelman8)
options:
  path:
    description:
    - URI being used to execute API calls.
    - Must end in C(.xml) or C(.json).
    required: true
    aliases: [ uri ]
  host:
    description:
    - IP Address or hostname of APIC resolvable by Ansible control host.
    required: true
  method:
    description:
    - The HTTP method of the request or response. It MUST be uppercase.
    required: true
    default: GET
    choices: [ DELETE, GET, POST ]
    aliases: [ action ]
  config_file:
    description:
    - Name of the absolute path of the filname that includes the body
      of the http request being sent to the ACI fabric.
  user:
    description:
    - Username used to login to the switch.
    required: true
    default: admin
    aliases: [ username ]
  password:
    description:
    - The password to use for authentication.
    required: true
    default: C1sco12345
  protocol:
    description:
    - Connection protocol to use.
    default: https
    choices: [ http, https ]
  timeout:
    description:
    - The socket level timeout in seconds.
    default: 30
  validate_certs:
    description:
    - If C(no), SSL certificates will not be validated. This should only set to C(no) used on personally controlled sites using self-signed certificates. Prior to 1.9.2 the code defaulted to C(no).
    default: 'yes'
    choices: [ 'no', 'yes' ]
'''

EXAMPLES = r'''
- name: Add a tenant
  aci_rest:
    config_file: /home/cisco/ansible/aci/configs/aci_config.xml
    path: /api/mo/uni.xml
    method: POST
    host: '{{ inventory_hostname }}'
    user: '{{ user }}'
    password: '{{ pass }}'
  connection: local

- name: Get tenants
  aci_rest:
    path: /api/node/class/fvTenant.json
    method: GET
    host: '{{ inventory_hostname }}'
    user: '{{ user }}'
    password: '{{ pass }}'
  connection: local

- name: Configure contracts
  aci_rest:
    config_file: /home/cisco/ansible/aci/configs/contract_config.xml
    path: /api/mo/uni.xml
    method: POST
    host: {{ inventory_hostname }}
    user: '{{ user }}'
    password: '{{ pass }}'
  connection: local

- name: Register leaves and spines
  aci_rest:
    path: /api/mo/uni/controller/nodeidentpol.xml
    method: POST
    content: |
      <fabricNodeIdentPol>
        <fabricNodeIdentP name="{{ item.name }}" nodeId="{{ item.nodeid }}" status="{{ item.status }}" serial="{{ item.serial }}"/>
      </fabricNodeIdentPol>
    host: '{{ apic_ip }}'
    user: '{{ apic_username }}'
    password: '{{ apic_password }}'
    validate_certs: no
  with_items:
  - '{{ apic_leavesspines }}'
  connection: local

- name: Waiting for all controllers to be ready
  aci_rest:
    path: /api/node/class/topSystem.json?query-target-filter=eq(topSystem.role,"controller")
    host: '{{ apic_ip }}'
    user: '{{ apic_username }}'
    password: '{{ apic_password }}'
    validate_certs: no
  register: apics
  until: "'totalCount' in apics and apics.totalCount|int >= groups['apic']|count"
  retries: 120
  delay: 30
  connection: local
  run_once: yes
'''

RETURN = r'''
response:
    description: HTTP response string
    returned: always
    type: string
    sample: OK
status:
    description: HTTP status code
    returned: always
    type: int
    sample: 200
'''

import json
# TODO: Would be nice to use xmltodict with Abdera convention support
#
#import xmltodict
import lxml.etree
from xmljson import cobra
import os

from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.pycompat24 import get_exception
from ansible.module_utils.urls import fetch_url

# FIXME: The XML-to-JSON conversion is using the newly implemented Abdera/Cobra convention
#        https://github.com/sanand0/xmljson/issues/16
#        https://github.com/martinblech/xmltodict/issues/157
def aci_response(rawoutput, rest_type='xml'):
    output = dict()
    result = dict(
        aci_code = -1,
        aci_text = 'This should not happen',
        output = rawoutput
    )
    if rest_type == 'xml':
        xml = lxml.etree.fromstring(rawoutput)
        imdata = cobra.data(xml)
        # Reformat as ACI does for JSON API output
        if 'children' in imdata['imdata']:
            output['imdata'] = imdata['imdata']['children']
        else:
            output['imdata'] = dict()
        output['totalCount'] = imdata['imdata']['attributes']['totalCount']
    elif rest_type == 'json':
        output = json.loads(rawoutput)
    else:
        result['aci_code'] = -2
        result['aci_text'] = 'Type %s not supported.' % rest_type
        return result

    if 'imdata' in output:
        if output['totalCount'] > 0 and 'error' in output['imdata'][0]:
            result['aci_code'] = output['imdata'][0]['error']['attributes']['code']
            result['aci_text'] = output['imdata'][0]['error']['attributes']['text']
        else:
            result['aci_code'] = 0
            result['aci_text'] = 'Success'
            result.update(output)

    return result

def main():

    module = AnsibleModule(
        argument_spec=dict(
            path=dict(type='str', required=True, aliases=['uri']),
            host=dict(type='str', required=True),
            method=dict(type='str', default='GET', choices=['DELETE', 'GET', 'POST'], aliases=['action']),
            config_file=dict(type='path'),
            content=dict(type='str'),
            user=dict(type='str', default='admin', aliases=['username']),
            password=dict(type='str', default='C1sco12345', no_log=True),
            protocol=dict(type='str', default='https', choices=['http', 'https']),
            timeout=dict(type='int', default=30),
            validate_certs=dict(type='bool', default=True),
        ),
        supports_check_mode=True,
        mutually_exclusive=[['config_file', 'content']],
    )

    path = module.params['path']
    content = module.params['content']
    config_file = module.params['config_file']

    protocol = module.params['protocol']
    method = module.params['method']
    timeout = module.params['timeout']

    host = module.params['host']
    user = module.params['user']
    password = module.params['password']

    result = dict(
        changed = False,
        data = '',
        output = '',
    )

    file_exists = False
    if config_file:
        if os.path.isfile(config_file):
            file_exists = True
        else:
            module.fail_json(msg='Cannot find/access config_file:\n%s' % config_file)

    url = '%s://%s/api/aaaLogin.xml' % (protocol, host)
    data = "<aaaUser name='%s' pwd='%s'/>" % (user, password)
    resp, auth = fetch_url(module, url, data=data, method="POST", timeout=timeout)

    if resp is None or auth['status'] >= 400:
        if 'body' in auth:
            result.update(aci_response(auth['body'], 'json'))
            result['msg'] = 'Authentication failed: %(aci_code)s %(aci_text)s' % result
        else:
            result['msg'] = '%(msg)s for %(url)s' % auth
        result['response'] = auth['msg']
        result['status'] = auth['status'],
        module.fail_json(**result)

    if content:
        result['data'] = content
    elif file_exists:
        with open(config_file, 'r') as config_object:
            result['data'] = config_object.read()

    if method in ('DELETE', 'POST'):
        # FIXME: Hardcoding changed is not idempotent
        result['changed'] = True

        # In check_mode we assume it works, but we don't actually perform the requested change
        if module.check_mode:
            module.exit_json(response='OK (Check mode)', status=200, **result)
    else:
        result['changed'] = False

    if path.find('.xml') != -1:
        rest_type = 'xml'
    elif path.find('.json') != -1:
        rest_type = 'json'
    else:
        module.fail_json(msg='Failed to find REST API content type (neither .xml nor .json).')

    url = '%s://%s/%s' % (protocol, host, path.lstrip('/'))
    headers = dict( Cookie=resp.headers['Set-Cookie'] )

    resp, info = fetch_url(module, url, data=result['data'], method=method, timeout=timeout, headers=headers)
    result['response'] = info['msg']
    result['status'] = info['status']

    if info['status'] != 200:
        result.update(aci_response(info['body'], rest_type))
        result['msg'] = 'Task failed: %(aci_code)s %(aci_text)s' % result
        module.fail_json(**result)

    result.update(aci_response(resp.read(), rest_type))
    module.exit_json(**result)

if __name__ == '__main__':
    main()
